"""
Parser for LLM responses.

This module provides utilities for parsing and extracting structured
information from LLM responses.
"""

import json
import re
import logging
from typing import Dict, Any, List, Optional, Union, Tuple


class ResponseParser:
    """Parser for extracting structured data from LLM responses.

    This class provides methods to extract various types of structured
    data from natural language responses generated by language models.
    """

    def __init__(self):
        """Initialize the response parser."""
        self.logger = logging.getLogger("llm.response_parser")

    def extract_json(self, text: str) -> Optional[Dict[str, Any]]:
        """Extract a JSON object from text.

        Args:
            text: The text containing JSON

        Returns:
            Extracted JSON as a dictionary, or None if extraction failed
        """
        # Try to find JSON in code blocks
        json_pattern = r'```(?:json)?\n(.*?)\n```'
        match = re.search(json_pattern, text, re.DOTALL)

        if match:
            json_str = match.group(1)
            try:
                return json.loads(json_str)
            except json.JSONDecodeError as e:
                self.logger.warning(f"Failed to parse JSON from code block: {e}")

        # If no code block or parsing failed, try to find JSON without code block markers
        try:
            # Look for content that looks like a JSON object
            json_like_pattern = r'\{.*\}'
            match = re.search(json_like_pattern, text, re.DOTALL)
            if match:
                json_str = match.group(0)
                return json.loads(json_str)
        except json.JSONDecodeError as e:
            self.logger.warning(f"Failed to parse JSON-like content: {e}")

        return None

    def extract_code(self, text: str, language: Optional[str] = None) -> List[Tuple[str, str]]:
        """Extract code blocks from text.

        Args:
            text: The text containing code blocks
            language: Optional language to filter for

        Returns:
            List of tuples (language, code) for each code block
        """
        # Match code blocks with or without language specifier
        code_pattern = r'```([a-zA-Z0-9_]*)\n(.*?)\n```'
        matches = re.finditer(code_pattern, text, re.DOTALL)

        code_blocks = []
        for match in matches:
            block_language = match.group(1).strip().lower()
            code = match.group(2)

            # If language filter is specified, skip non-matching blocks
            if language and block_language and block_language != language:
                continue

            code_blocks.append((block_language, code))

        return code_blocks

    def extract_list(self, text: str) -> List[str]:
        """Extract a bullet or numbered list from text.

        Args:
            text: The text containing a list

        Returns:
            List of extracted items
        """
        # Match both bullet lists and numbered lists
        list_pattern = r'(?:^|\n)(?:[-*]|\d+\.)\s+(.+)'
        matches = re.finditer(list_pattern, text)

        items = []
        for match in matches:
            items.append(match.group(1).strip())

        return items

    def extract_key_value_pairs(self, text: str) -> Dict[str, str]:
        """Extract key-value pairs from text.

        Args:
            text: The text containing key-value pairs

        Returns:
            Dictionary of extracted key-value pairs
        """
        # Match key-value pairs in formats like "Key: Value" or "Key = Value"
        kv_pattern = r'(?:^|\n)([A-Za-z0-9_\s]+)(?::|=)\s+(.+)'
        matches = re.finditer(kv_pattern, text)

        pairs = {}
        for match in matches:
            key = match.group(1).strip()
            value = match.group(2).strip()
            pairs[key] = value

        return pairs

    def extract_mermaid_diagram(self, text: str) -> Optional[str]:
        """Extract Mermaid diagram code from text.

        Args:
            text: The text containing a Mermaid diagram

        Returns:
            Extracted Mermaid diagram code, or None if not found
        """
        # Match Mermaid code blocks
        mermaid_pattern = r'```mermaid\n(.*?)\n```'
        match = re.search(mermaid_pattern, text, re.DOTALL)

        if match:
            return match.group(1)

        return None

    def extract_numbered_sections(self, text: str) -> Dict[str, str]:
        """Extract numbered sections from text.

        Args:
            text: The text containing numbered sections

        Returns:
            Dictionary of section numbers/titles to section content
        """
        # Match section headings and content
        section_pattern = r'(?:^|\n)(\d+\.(?:\d+\.?)?\s+[^\n]+)\n(.*?)(?=\n\d+\.(?:\d+\.?)?\s+[^\n]+|\Z)'
        matches = re.finditer(section_pattern, text, re.DOTALL)

        sections = {}
        for match in matches:
            heading = match.group(1).strip()
            content = match.group(2).strip()
            sections[heading] = content

        return sections